//server.js
const express= require('express');
const dotenv= require('dotenv').config();
const dbConnect = require('./config/dbConnect'); 
// Importing the database connection function
const userRoutes = require('./routes/userRoutes'); // Importing user routes
//importing packages
const authRoutes = require('./routes/authRoutes'); // Importing authentication routes
dbConnect(); // Establishing the database connection

const app= express();


// Middleware
app.use(express.json());

app.use("/api/auth", authRoutes); // Using authentication routes
app.use("/api/users", userRoutes); // Using authentication routes

//start the server
const PORT= process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});


//userModel.js
const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
  username: {
    type: String,
    required: true,
    unique: true, // Ensures that userName is unique across users
  },
 
  password: {
    type: String,
    required: true,
  },
email: {
    type: String,
    required: true,
    unique: true, // Ensures that email is unique across users
    match: /.+\@.+\..+/ // Basic regex to validate email format
  },


  role: {
    type: String,
required: true,
    enum: ['admin','manager','user',], // Only allows 'admin' or 'user' as valid roles
    default: 'user', // Default role is 'user'
  },
  
}, {
  timestamps: true, // Automatically manage createdAt and updatedAt fields
});

module.exports = mongoose.model('User', userSchema);


//AuthMiddleware.js
const jwt=require("jsonwebtoken");
const { head } = require("../routes/userRoutes");

const verifyToken=(req,res,next)=>{
let token;
let authHeader=req.headers.authorization || req.headers.Authorization;
if(authHeader && authHeader.startsWith("Bearer")){
    token=authHeader.split(" ")[1];}
if(!token){
    return res.status(401).json({message:"Not authorized, no token"});}


try {
 const decoded=jwt.verify(token,process.env.JWT_SECRET);
 req.user=decoded; // Assuming the token contains user id
 console.log("decoded user is :", req.user);
 next(); // Proceed to the next middleware or route handler
}
catch (error) {
    return res.status(400).json({message:"Not authorized, token failed"});}
}



module.exports =verifyToken;
//roleMiddleware.js
const authozizeRoles =(...allowedRoles)=>{

    return (req, res, next) => {
        if (!req.user) {
            return res.status(403).json({ message: "Access denied. No user found." });
        }

        const userRole = req.user.role;

        if (!allowedRoles.includes(userRole)) {
            return res.status(403).json({ message: `Access denied. User role '${userRole}' is not allowed.` });
        }

        next();
    };
}

module.exports =authozizeRoles;
//authController.js

const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const User = require('../models/userModel');


const register =async (req,res) => {
    try {
        const { username,email, password ,role} = req.body;
        const hashedPassword = await bcrypt.hash(password, 10);
        const newUser = new User({
            username,
            email,
            password: hashedPassword,
            role,
        });

        await newUser.save();
        res.status(201).json({
            message: `User registered successfully ${username}`,
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
};

const login = async(req,res) => {
    try {
        const { email, password } = req.body;
        const user = await User.findOne({ email });
        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }    
        const isMatch = await bcrypt.compare(password, user.password); 
    
        if (!isMatch) {
            return res.status(400).json({ message: 'Invalid credentials' });
        }
    const token = jwt. sign({ id: user ._id, role: user.role },process.env.JWT_SECRET, {
        expiresIn: '1h', // Token expiration time
        });
        res.status(200).json({
            message: `User logged in successfully ${email}`,
            token,
        });
    }  catch (error) {
      res.status(500).json({ message:`something went wrong${error}` });
    }
};

module. exports = {
register,
login,

};

//dbConnect.js

const mongoose = require('mongoose');

const dbConnect = async () => {
  try {
   const connect= await mongoose.connect(process.env.CONNECTION_STRING);
    console.log(`MongoDB connected successfully: ${connect.connection.host},${connect.connection.name}`);

  } catch (error) {
    console.error('MongoDB connection error:', error);
    process.exit(1); // Exit the process with failure
  }
}

module.exports = dbConnect;


//authRoutes.js
const express = require("express");
const { register, login } = require("../controllers/authController");
const router = express. Router() ;

router.post("/register", register);
router.post("/login", login);

module.exports = router;

// userRoutes.js
const express = require('express');
const verifyToken = require('../middlewares/authMiddleware');
const authozizeRoles= require('../middlewares/roleMiddleware'); // Importing the role authorization middleware
// Importing the authentication middleware
const router = express.Router();

//only admin can access this route
router.get("/admin",verifyToken,authozizeRoles("admin") ,(req, res) => {
  res.json({ message: "Welcome Admin" });
});
//admin and manager can access this route
router.get("/manager", verifyToken,authozizeRoles("admin","manager") , (req, res) => {
  res.json({ message: "Welcome Manager" });
});
//all users can access this route
router.get("/user",verifyToken, authozizeRoles("user") , (req, res) => {
  res.json({ message: "Welcome User" });
});


module.exports = router;